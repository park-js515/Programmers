# [level 4] 올바른 괄호의 갯수 - 12929

<a href="../../../프로그래머스/4/12929. 올바른 괄호의 갯수/올바른 괄호의 갯수.java">java 풀이</a>

## 문제 풀이

- 알고리즘: DP

- 패턴 찾기

  ```
  0:
  1: (``)
  2: (`()`), (``)()
  3: (`(())`), (`()()`), (`()`)(), (``)(()), (``)()()
  ```

- 무엇이 보이는가?

  - 0 단계: 아무것도 없는 것도 하나의 경우로 볼 수 있다.
  - 1 단계: 0 단계에서 하나의 괄호를 추가한 것으로 볼 수 있다.
  - 2 단계: 0 \* 1, 1 \* 0 단계의 형태로 볼 수 있다.
  - 3 단계: 0 \* 2, 1 \* 1, 2 \* 0
  - ...
  - **결론: 전자를 괄호로 감싸고, 후자를 더하는 형태로 볼 수 있다.**
  - 반대로 후자를 감싸는 형태로 생각할 수도 있는데, 대칭이므로 이는 동치이다.

- 점화식

  ```java
  dp[i] = dp[0] * dp[i - 1] + dp[1] * dp[i - 2] + dp[2] * dp[i - 3] + ...
  ```

- 번외: 또 다른 관점으로는 전체 괄호가 하나의 괄호로 묶여 있냐 여부로도 점화식을 구성할 수 있다.
  - 점화식의 형태가 달라질 수 있으나, 궁극적인 점화식은 같다.

## 정답

```java
class Solution {
    public int solution(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for (int i = 1; i < n + 1; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }

        return dp[n];
    }
}
```

```java
class Solution {
    public int solution(int n) {
        int[] dp1 = new int[n + 1];
        int[] dp2 = new int[n + 1];
        dp1[0] = 1;

        for (int i = 1; i < n + 1; i++) {
            dp2[i] = dp1[i - 1];
            for (int j = 0; j < i; j++) {
                dp1[i] += dp1[j] * dp2[i - j];
            }

        }

        return dp1[n];
    }
}
```
